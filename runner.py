from collections import deque
from collections.abc import Callable
import csv
import os
import time
from xml.etree import ElementTree
from circuit import Circuit
from circuiterror import compute_error
from ml_algorithms.decision_tree import DecisionTreeCircuit
from pruning_algorithms.ccarving import FindCut
from pruning_algorithms.glpsignificance import GetbySignificance, LabelCircuit
from pruning_algorithms.inouts import GetInputs, GetOutputs
from pruning_algorithms.probprun import GetOneNode
from utils import read_dataset
from configuration import AlsMethod, ApproxSynthesisConfig, Metric

type Results = dict[Metric, float]

# Directory to output build files to.
# TODO: Consider making this a config parameter.
BUILD_DIR = f"{os.path.dirname(__file__)}/build"

# Files generated by the different methods. Defined here to just reuse in the
# code.
APPROX_RTL = f"{BUILD_DIR}/.approx.v"

RESYNTH_RTL = f"{BUILD_DIR}/.resynth.v"

EXACT_OUTPUT = f"{BUILD_DIR}/.exact_output"
APPROX_OUTPUT = f"{BUILD_DIR}/.approx_output"
TEMP_OUTPUT = f"{BUILD_DIR}/.tmp_output"

TB = f"{BUILD_DIR}/.tb.v"

VALIDATION_DATASET = f"{BUILD_DIR}/.v_dataset"
VALIDATION_TB = f"{BUILD_DIR}/.v_tb.v"
VALIDATION_EXACT_OUTPUT = f"{BUILD_DIR}/.v_exact_output"
VALIDATION_APPROX_OUTPUT = f"{BUILD_DIR}/.v_approx_output"

VCD = f"{BUILD_DIR}/.vcd"
VCD_TB = f"{BUILD_DIR}/.vcd_tb.v"
SAIF = f"{BUILD_DIR}/.saif"


def run(config: ApproxSynthesisConfig) -> tuple[Results, Results | None]:
    """
    Runner function for an execution specified by a valid ApproxSynthesisConfig.
    This function will do the following steps:
    - Simulate the exact circuit
    - Carry out the given ALS method
    - Calculate the metrics given in config.metrics and return them as a Results
      dict.

    If the 'validation' option is set, it will also return a second Results
    object which contains the error metrics specified, calculated on the
    validation set. It won't include non-error metrics like area or time since
    those won't change based on the dataset.
    """
    if not os.path.exists(BUILD_DIR):
        os.makedirs(BUILD_DIR)

    _create_tbs_and_exact_outputs(config)

    # The benchmark functions should return the final approximated circuit (for
    # area calculation and validation simulation) and also carry out the final
    # simulation to generate the APPROX_OUTPUT that will be used to calculate
    # error metrics.
    #
    # We want the benchmark_fn to carry out this final simulation because a lot
    # of the methods need to carry out simulations in order to iterate (for
    # example the constant inputs and outputs methods), so it's better to make
    # use of those simulations instead of re-running the same sim outside of the
    # benchmark_fn.
    benchmark_fn: Callable[[ApproxSynthesisConfig], Circuit]
    match config.method:
        case AlsMethod.CONSTANT_INPUTS:
            benchmark_fn = _run_constant_inputs
        case AlsMethod.CONSTANT_OUTPUTS:
            benchmark_fn = _run_constant_outputs
        case AlsMethod.PROBPRUN:
            _create_saif(config)
            benchmark_fn = _run_probprun
        case AlsMethod.SIGNIFICANCE:
            benchmark_fn = _run_significance
        case AlsMethod.CCARVING:
            benchmark_fn = _run_ccarving
        case AlsMethod.DECISION_TREE:
            benchmark_fn = _run_decision_tree

    # Timed code includes:
    # - Execution of ALS method.
    # - Simulation of approximated circuit.
    # - Calculation of all metrics.
    #
    # We include simulations and calculation of all metrics because, even though
    # they don't contribute directly to generating the final circuit, they are
    # a necessary part of ALS in order to learn the circuit's characteristics
    # and whether it's a worthwhile candidate.
    start_time = time.perf_counter()

    original_area = float(config.circuit.get_area())

    approx_circuit = benchmark_fn(config)

    if config.validation is not None:
        approx_circuit.simulate(VALIDATION_TB, VALIDATION_APPROX_OUTPUT)

    results, validation_results = _compute_error_metrics(config)

    if Metric.AREA in config.metrics:
        approx_area = float(approx_circuit.get_area())
        results[Metric.AREA] = approx_area / original_area

    end_time = time.perf_counter()

    if Metric.ALS_TIME in config.metrics:
        elapsed_time = end_time - start_time
        results[Metric.ALS_TIME] = elapsed_time

    # For debugging or checking the final output
    approx_circuit.write_to_disk(APPROX_RTL)

    if config.csv:
        _write_results_to_csv(config, results, validation_results)

    return results, validation_results


def _create_saif(config: ApproxSynthesisConfig):
    """
    If the circuit doesn't have timing information, create a SAIF file and
    annotate the circuit with its data.
    """

    nodes = config.circuit.netl_root.findall("node")
    node_outputs = [node.findall("output")[0] for node in nodes]
    circuit_has_timing_info = all(
        "t1" in node_output.attrib for node_output in node_outputs
    )

    if circuit_has_timing_info:
        print("Circuit already has timing info, skipping SAIF generation")
        return

    config.circuit.write_tb(
        VCD_TB,
        config.dataset,
        dump_vcd=VCD,
        show_progress=config.show_progress,
    )
    config.circuit.exact_output(VCD_TB, EXACT_OUTPUT)
    config.circuit.generate_saif_from_vcd(SAIF, VCD)


def _write_results_to_csv(
    config: ApproxSynthesisConfig, results: Results, validation_results: None | Results
):
    """
    Writes the execution results to a CSV file as a single row.
    """
    assert config.csv is not None, (
        "_write_results_to_csv should only be called if a csv file was given by the user"
    )

    file_exists = os.path.isfile(config.csv)

    with open(config.csv, mode="a", newline="") as file:
        writer = csv.writer(file)
        # If the file does not exist, write the header
        if not file_exists:
            writer.writerow(config.csv_columns())

        writer.writerow(config.csv_values(results, validation_results))


def _run_decision_tree(config: ApproxSynthesisConfig) -> Circuit:
    exact_circuit = config.circuit
    outputs = read_dataset(EXACT_OUTPUT, 10)
    inputs = read_dataset(config.dataset, 16, max_lines=len(outputs))
    # We use max_lines because the output set might be smaller due to a
    # validation set being used

    tree = DecisionTreeCircuit(
        exact_circuit.inputs,
        exact_circuit.outputs,
        one_tree_per_output=config.one_tree_per_output,
        max_depth=config.max_depth,
    )

    tree.train(inputs, outputs)
    tree.to_verilog_file(exact_circuit.topmodule, APPROX_RTL)
    print("Synthesizing circuit from trained decision tree, this might take a while...")
    tree_circuit = Circuit(
        APPROX_RTL, exact_circuit.tech_file, topmodule=exact_circuit.topmodule
    )

    if config.resynthesis:
        tree_circuit.resynth()

    tree_circuit.simulate(TB, APPROX_OUTPUT)

    return tree_circuit


def _run_constant_inputs(config: ApproxSynthesisConfig) -> Circuit:
    return _run_constant_inputs_outputs(config, config.circuit.inputs, "inputs")


def _run_constant_outputs(config: ApproxSynthesisConfig) -> Circuit:
    return _run_constant_inputs_outputs(config, config.circuit.outputs, "outputs")


def _run_constant_inputs_outputs(
    config: ApproxSynthesisConfig, circuit_variables: list[str], inputs_or_outputs: str
) -> Circuit:
    """
    The InOuts method accepts either a list of inputs or outputs to make
    constant, and then returns a list of nodes that could be pruned.

    The selection of which input/outputs to make constant is not part of the
    InOuts method, so each user must select them under whichever criteria fits
    their use case best.

    For this runner execution, which must use a generic heuristic for any
    circuit, we'll select the LSBs of each input/output to be constant. If we
    manage to prune all the suggested nodes without going over the error
    threshold or the max iterations then we can use the next LSB of each
    input/output. For example, in a circuit with the input/outputs:

        ["in1[2]", "in1[1]", "in1[0]", "in2[2]", "in2[1]", "in2[0]", cin]

    We'll first prune the nodes suggested when ["in1[0]", "in2[0]", cin] are set
    as constants. If we delete all the suggested nodes then we'll move on to the
    nodes suggested when ["in1[0]", "in1[1]", "in2[0]", "in2[1]", cin] are
    constants.
    """
    circuit = config.circuit

    assert config.error is not None, (
        f"'error' should be given when executing {config.method}"
    )

    max_const_bit = 0
    iteration = 0
    max_iters = config.max_iters if config.max_iters else float("inf")

    while iteration < max_iters:
        deletable_nodes: list[ElementTree.Element]
        nodes_to_delete: list[ElementTree.Element] = []

        while len(nodes_to_delete) < config.prunes_per_iteration:
            const_variables = _get_lsbs_up_to(circuit_variables, max_const_bit)

            match inputs_or_outputs:
                case "inputs":
                    deletable_nodes = GetInputs(circuit.netl_root, const_variables)
                case "outputs":
                    deletable_nodes = GetOutputs(circuit.netl_root, const_variables)
                case _:
                    raise ValueError("Invalid call to _run_constant_inputs_outputs")

            # Filter Already deleted nodes
            deletable_nodes = [
                node
                for node in deletable_nodes
                if (
                    node.get("delete") != "yes"
                    and node.attrib["var"]
                    not in [
                        node_to_delete.attrib["var"]
                        for node_to_delete in nodes_to_delete
                    ]
                )
            ]

            if len(deletable_nodes) == 0:
                if set(const_variables) == set(circuit_variables):
                    # All variables have been set as const and all elected nodes
                    # have been deleted. This mean we already deleted all
                    # possible nodes that could be deleted.
                    if len(nodes_to_delete) != 0:
                        # There might be some nodes to delete from a previous
                        # iteration of this loop, so finish deleting those.
                        break
                    else:
                        # Nothing left to do, finish execution.
                        return circuit
                else:
                    max_const_bit += 1
                    continue

            max_nodes_to_append = config.prunes_per_iteration - len(nodes_to_delete)
            nodes_to_delete.extend(deletable_nodes[:max_nodes_to_append])

        nodes_to_delete_names = [node.attrib["var"] for node in nodes_to_delete]
        print(f"Iteration {iteration + 1}: Pruning nodes {nodes_to_delete_names}")

        for node in nodes_to_delete:
            node.set("delete", "yes")

        if config.resynthesis:
            circuit.resynth()

        error = circuit.simulate_and_compute_error(
            TB, EXACT_OUTPUT, TEMP_OUTPUT, Metric.MEAN_RELATIVE_ERROR_DISTANCE
        )

        print(f"Pruned circuit error: {error}")

        if error > config.error:
            print("Error has overpassed threshold, backtracking...\n")
            _undo_prunes(circuit, nodes_to_delete, config.error)
            os.replace(TEMP_OUTPUT, APPROX_OUTPUT)
            break

        iteration += 1
        os.replace(TEMP_OUTPUT, APPROX_OUTPUT)

    return circuit


def _run_probprun(config: ApproxSynthesisConfig) -> Circuit:
    # TODO (Possible improvement): After pruning some nodes, if we re-simulate
    # the cirucit re-generating the vcd file, and with the new vcd re-generate
    # the SAIF, one can notice a different timing behaviour from the remaining
    # existing nodes. We don't re-simulate and re-generate the SAIF because the
    # python method to regenerate the SAIF takes really long even for small
    # datasets. (Example: BK_16b, 4000 inputs, takes ~30 seconds to generate
    # SAIF.) But, if we find a way to generate the SAIF file quickly, for example
    # using a faster language for it, we might want to regenerate it on every
    # iteration or every N iterations.

    circuit = config.circuit
    circuit_root = circuit.netl_root

    assert config.error is not None, (
        f"'error' should be given when executing {config.method}"
    )

    iteration = 0
    max_iters = config.max_iters if config.max_iters else float("inf")

    probprun = GetOneNode(circuit_root)
    while iteration < max_iters:
        nodes_to_delete = []
        nodes_info = []

        for (node, output, time_percent), _ in zip(
            probprun, range(config.prunes_per_iteration)
        ):
            node_to_delete = circuit_root.find(f"./node[@var='{node}']")

            assert node_to_delete is not None, (
                f"Node {node} suggested by ProbPrun should be findable in the circuit"
            )

            nodes_to_delete.append(node_to_delete)
            nodes_info.append((output, time_percent))

        if len(nodes_to_delete) == 0:
            # If no nodes were appended it means there's no nodes left to delete
            return circuit

        nodes_to_delete_names = [node.attrib["var"] for node in nodes_to_delete]

        print(
            f"Iteration {iteration + 1}: Pruning nodes {nodes_to_delete_names} because:"
        )
        for node, (output, time_percent) in zip(nodes_to_delete_names, nodes_info):
            print(f"{node} is {output} {time_percent}% of the time")

        for node in nodes_to_delete:
            node.set("delete", "yes")

        if config.resynthesis:
            resynth_circuit = copy.copy(circuit)
            resynth_circuit.resynth()
            error = resynth_circuit.simulate_and_compute_error(
                TB, EXACT_OUTPUT, TEMP_OUTPUT, Metric.MEAN_RELATIVE_ERROR_DISTANCE
            )
        else:
            error = circuit.simulate_and_compute_error(
                TB, EXACT_OUTPUT, TEMP_OUTPUT, Metric.MEAN_RELATIVE_ERROR_DISTANCE
            )

        print(f"Pruned circuit error: {error}")

        if error > config.error:
            print("Error has overpassed threshold, backtracking...\n")
            _undo_prunes(circuit, nodes_to_delete, config.error, config.resynthesis)
            os.replace(TEMP_OUTPUT, APPROX_OUTPUT)
            break

        if config.resynthesis:
            circuit = resynth_circuit

        iteration += 1
        os.replace(TEMP_OUTPUT, APPROX_OUTPUT)

    return circuit


def _run_significance(config: ApproxSynthesisConfig) -> Circuit:
    circuit = config.circuit
    circuit_root = circuit.netl_root

    assert config.error is not None, (
        f"'error' should be given when executing {config.method}"
    )

    iteration = 0
    max_iters = config.max_iters if config.max_iters else float("inf")

    if config.output_significances is not None:
        output_significances = config.output_significances
    else:
        output_significances = []

    for node, significance in GetbySignificance(circuit_root, output_significances):
        if iteration >= max_iters:
            break

        node_to_delete = circuit_root.find(f"./node[@var='{node}']")

        assert node_to_delete is not None, (
            f"Node {node} suggested by GetbySignificance should be findable in the circuit"
        )

        print(
            f"Iteration {iteration + 1}: Pruning node {node} because its significance is {significance}"
        )
        node_to_delete.set("delete", "yes")

        if config.resynthesis:
            circuit.resynth()

        error = circuit.simulate_and_compute_error(
            TB, EXACT_OUTPUT, TEMP_OUTPUT, Metric.MEAN_RELATIVE_ERROR_DISTANCE
        )

        print(f"Pruned circuit error: {error}")

        if error > config.error:
            print("Error has overpassed threshold, undoing last prune\n")
            node_to_delete.set("delete", "no")
            break

        iteration += 1
        os.replace(TEMP_OUTPUT, APPROX_OUTPUT)

    return circuit


def _run_ccarving(config: ApproxSynthesisConfig) -> Circuit:
    circuit = config.circuit
    circuit_root = circuit.netl_root

    assert config.error is not None, (
        f"'error' should be given when executing {config.method}"
    )

    iteration = 0
    max_iters = config.max_iters if config.max_iters else float("inf")

    if config.output_significances is not None:
        output_significances = config.output_significances
    else:
        output_significances = []

    # TODO: Allow specifying the diff threshold in the config
    diff_threshold = 2 ** (len(circuit.outputs)) - 1

    # TODO: NEED to add harshness_level to the config.
    harshness_level = 1

    # Currently (May 2025) significance is the only relevant difference metric
    # that we have available, if this changes in the future 'diff' could be added
    # as a config parameter.
    diff = "significance"

    LabelCircuit(circuit_root, output_significances)

    while iteration < max_iters:
        print("Finding cuts...", flush=True)

        cuts = FindCut(circuit_root, diff_threshold, diff, harshness_level)

        nodes_to_delete = cuts[0]
        nodes_to_delete_names = [n.attrib["var"] for n in nodes_to_delete]

        print(
            f"Iteration {iteration + 1}: Pruning nodes {nodes_to_delete_names} as a single cut...\n"
        )
        [n.set("delete", "yes") for n in nodes_to_delete]

        if config.resynthesis:
            circuit.resynth()

        error = circuit.simulate_and_compute_error(
            TB, EXACT_OUTPUT, TEMP_OUTPUT, Metric.MEAN_RELATIVE_ERROR_DISTANCE
        )

        print(f"Pruned circuit error: {error}")

        if iteration > 0 and error > config.error:
            print("Error has overpassed threshold, undoing last prune\n")
            [n.set("delete", "no") for n in nodes_to_delete]
            break

        iteration += 1
        os.replace(TEMP_OUTPUT, APPROX_OUTPUT)

    return circuit


def _compute_error_metrics(
    config: ApproxSynthesisConfig,
) -> tuple[Results, Results | None]:
    results: Results = {}
    if config.validation is not None:
        validation_results = {}
    else:
        validation_results = None

    for metric in config.metrics:
        if metric.is_error_metric():
            error = compute_error(metric.value, EXACT_OUTPUT, APPROX_OUTPUT)
            results[metric] = error
            if validation_results is not None and config.validation != 0:
                error = compute_error(
                    metric.value, VALIDATION_EXACT_OUTPUT, VALIDATION_APPROX_OUTPUT
                )
                validation_results[metric] = error

    return results, validation_results


def _get_lsbs_up_to(variables: list[str], bit_index: int) -> list[str]:
    """
    Get a list of circuit variables with bits up to a specified index.

    Parameters
    ----------
    variables : list of str
        A list of circuit variable strings, which may include bit indices in the format 'var[bit_index]' or just 'var'.
    bit_index : int
        The bit index up to which the variables should be included in the result.

    Returns
    -------
    list of str
        A list of variables that have a bit index less than or equal to the specified bit index.
        If a variable does not have a bit index (e.g., 'cin'), it is included in the result.

    Examples
    --------
    >>> variables = ["in1[2]", "in1[1]", "in1[0]", "in2[2]", "in2[1]", "in2[0]", "cin"]
    >>> get_lsbs_up_to(variables, 0)
    ['in1[0]', 'in2[0]', 'cin']

    >>> get_lsbs_up_to(variables, 1)
    ['in1[0]', 'in1[1]', 'in2[0]', 'in2[1]', 'cin']

    >>> get_lsbs_up_to(["out[0]", "out[1]", "out[2]"], 0)
    ['out[0]']
    """
    result = []
    for var in variables:
        # Check if the variable is a string and contains a bit index
        if "[" in var and "]" in var:
            # Extract the bit index from the variable string
            start = var.index("[") + 1
            end = var.index("]")
            var_bit_index = int(var[start:end])

            # Check if the variable's bit index is less than or equal to the specified bit index
            if var_bit_index <= bit_index:
                result.append(var)
        else:
            # If it's not a variable with a bit index, add it directly (e.g., cin)
            result.append(var)

    return result


def _create_tbs_and_exact_outputs(config: ApproxSynthesisConfig):
    """
    Generate test and validation testbenches along with their exact outputs
    based on the provided configuration.

    If a validation fraction is specified, the function splits the dataset into
    test and validation sets, creating corresponding testbenches and exact
    outputs; otherwise, it creates a single testbench using the full dataset.
    """
    if config.validation is not None:
        # Count the number of inputs in the dataset
        with open(config.dataset, "r") as file:
            total_lines = sum(1 for _ in file)

        # Create TB that reads only the test dataset
        test_dataset_size = int(round((1 - config.validation) * total_lines))
        config.circuit.write_tb(
            TB,
            config.dataset,
            show_progress=config.show_progress,
            iterations=test_dataset_size,
        )
        config.circuit.exact_output(TB, EXACT_OUTPUT)

        # Create validation TB
        validation_dataset_size = int(round(config.validation * total_lines))
        _copy_last_n_lines(config.dataset, VALIDATION_DATASET, validation_dataset_size)
        config.circuit.write_tb(
            VALIDATION_TB, VALIDATION_DATASET, show_progress=config.show_progress
        )
        config.circuit.exact_output(VALIDATION_TB, VALIDATION_EXACT_OUTPUT)
    else:
        # No validation set, just create a regular TB using the full dataset
        config.circuit.write_tb(TB, config.dataset, show_progress=config.show_progress)
        config.circuit.exact_output(TB, EXACT_OUTPUT)


def _copy_last_n_lines(input_file: str, output_file: str, n: int) -> None:
    """
    Copy the last N lines from an input file to an output file.

    Used to create a validation dataset from the original dataset.
    """
    with open(input_file, "r") as infile:
        last_n_lines = deque(infile, maxlen=n)

    with open(output_file, "w") as outfile:
        outfile.writelines(last_n_lines)


def _undo_prunes(
    circuit, deleted_nodes: list[ElementTree.Element], error_threshold: float
):
    """
    Will set the deleted_nodes "delete" propert to "no". Then simulates the
    circuit and if the error is less than the error_threshold it returns.
    Meant for backtracking the last iteration of prunes when the error threshold
    is surpassed.
    """
    for node in reversed(deleted_nodes):
        print(f"Undoing prune on node {node.attrib['var']}")
        node.set("delete", "no")
        error = circuit.simulate_and_compute_error(
            TB, EXACT_OUTPUT, TEMP_OUTPUT, Metric.MEAN_RELATIVE_ERROR_DISTANCE
        )
        print(f"New error: {error}")
        if error < error_threshold:
            print("Error back to being under threshold, backtracking finished")
            return

    print("Reverted all prunes.")
    return
