from collections.abc import Callable
import csv
import os
import time
from circuit import Circuit
from circuiterror import compute_error
from ml_algorithms.decision_tree import DecisionTreeCircuit
from utils import read_dataset
from configuration import AlsMethod, ApproxSynthesisConfig, Metric

type Results = dict[Metric, float]

# Directory to output build files to.
# TODO: Consider making this a config parameter.
BUILD_DIR = "build"

# Files generated by the different methods. Defined here to just reuse in the
# code.
APPROX_RTL = f"{BUILD_DIR}/.approx.v"

RESYNTH_RTL = f"{BUILD_DIR}/.resynth.v"

EXACT_OUTPUT = f"{BUILD_DIR}/.exact_output"
APPROX_OUTPUT = f"{BUILD_DIR}/.approx_output"
RESYNTH_OUTPUT = f"{BUILD_DIR}/.resynth_output"

TB = f"{BUILD_DIR}/.tb.v"

VCD = f"{BUILD_DIR}/.vcd"
SAIF = f"{BUILD_DIR}/.saif"

# This list should contain all the Metrics that are related to approximation
# errors.
_APPROXIMATION_ERROR_METRICS: list[Metric] = [
    Metric.HAMMING_DISTANCE,
    Metric.MEAN_ERROR_DISTANCE,
    Metric.WORST_CASE_ERROR,
    Metric.MEAN_RELATIVE_ERROR_DISTANCE,
    Metric.MEAN_SQUARED_ERROR_DISTANCE,
]


def run(config: ApproxSynthesisConfig) -> Results:
    """
    Runner function for an execution specified by a valid ApproxSynthesisConfig.
    This function will do the following steps:
    - Simulate the exact circuit
    - Carry out the given ALS method
    - Calculate the metrics given in config.metrics and return them as a Results
      dict.
    """
    if not os.path.exists(BUILD_DIR):
        os.makedirs(BUILD_DIR)

    config.circuit.write_tb(
        TB, config.dataset, show_progress=config.show_progress
    )
    config.circuit.exact_output(TB, EXACT_OUTPUT)

    # The benchmark functions should return the final approximated circuit (for
    # area calculation) and also carry out the final simulation to generate the
    # APPROX_OUTPUT that will be used to calculate error metrics.
    benchmark_fn: Callable[[ApproxSynthesisConfig], Circuit]
    match config.method:
        case AlsMethod.CONSTANT_INPUTS:
            benchmark_fn = _run_constant_inputs
        case AlsMethod.CONSTANT_OUTPUTS:
            benchmark_fn = _run_constant_outputs
        case AlsMethod.PROBRUN:
            _create_saif(config)
            benchmark_fn = _run_probrun
        case AlsMethod.SIGNIFICANCE:
            benchmark_fn = _run_significance
        case AlsMethod.CCARVING:
            benchmark_fn = _run_ccarving
        case AlsMethod.DECISION_TREE:
            benchmark_fn = _run_decision_tree

    # Timed code includes:
    # - Execution of ALS method.
    # - Simulation of approximated circuit.
    # - Calculation of all metrics.
    start_time = time.perf_counter()

    original_area = float(config.circuit.get_area())

    approx_circuit = benchmark_fn(config)
    results = _compute_error_metrics(config)

    if Metric.AREA in config.metrics:
        approx_area = float(approx_circuit.get_area())
        results[Metric.AREA] = approx_area / original_area

    end_time = time.perf_counter()

    if Metric.ALS_TIME in config.metrics:
        elapsed_time = end_time - start_time
        results[Metric.ALS_TIME] = elapsed_time

    if config.csv:
        _write_results_to_csv(config, results)

    return results


def _create_saif(config: ApproxSynthesisConfig):
    """
    Create a SAIF file and annotate the circuit with its data
    """

    VCD_TB = f"{BUILD_DIR}/.vcd_tb.v"

    config.circuit.write_tb(
        VCD_TB,
        config.dataset,
        dump_vcd=VCD,
        show_progress=config.show_progress,
    )
    config.circuit.exact_output(VCD_TB, EXACT_OUTPUT)
    config.circuit.generate_saif_from_vcd(SAIF, VCD)


def _write_results_to_csv(config: ApproxSynthesisConfig, results: Results):
    """
    Writes the execution results to a CSV file as a single row.
    """
    assert config.csv is not None, (
        "_write_results_to_csv should only be called if a csv file was given by the user"
    )

    file_exists = os.path.isfile(config.csv)

    with open(config.csv, mode="a", newline="") as file:
        writer = csv.writer(file)
        # If the file does not exist, write the header
        if not file_exists:
            writer.writerow(config.csv_columns())
        writer.writerow(config.csv_values(results))


def _run_decision_tree(config: ApproxSynthesisConfig) -> Circuit:
    exact_circuit = config.circuit
    inputs = read_dataset(config.dataset, 16)
    outputs = read_dataset(EXACT_OUTPUT, 10)

    tree = DecisionTreeCircuit(
        exact_circuit.inputs,
        exact_circuit.outputs,
        one_tree_per_output=config.one_tree_per_output,
        max_depth=config.max_depth,
    )

    tree.train(inputs, outputs)
    tree.to_verilog_file(exact_circuit.topmodule, APPROX_RTL)
    tree_circuit = Circuit(
        APPROX_RTL, exact_circuit.tech_file, topmodule=exact_circuit.topmodule
    )

    if not config.resynthesis:
        tree_circuit.simulate(TB, APPROX_OUTPUT)

    else:
        tree_circuit.resynth()
        tree_circuit.simulate(TB, APPROX_OUTPUT)
        error = compute_error(
            Metric.MEAN_RELATIVE_ERROR_DISTANCE, EXACT_OUTPUT, APPROX_OUTPUT
        )

        assert isinstance(config.error, float), (
            "'error' should be given when executing decision tree with resynthesis"
        )

        if error > config.error:
            return tree_circuit

        assert isinstance(config.max_iters, int), (
            "'max_iters' should be given when executing decision tree with resynthesis"
        )

        for _ in range(config.max_iters):
            last_output = read_dataset(APPROX_OUTPUT, 10)

            tree.train(inputs, last_output)
            tree.to_verilog_file(exact_circuit.topmodule, RESYNTH_RTL)

            resynth_circuit = Circuit(
                RESYNTH_RTL, exact_circuit.tech_file, topmodule=exact_circuit.topmodule
            )
            resynth_circuit.simulate(TB, RESYNTH_OUTPUT)

            error = compute_error(
                Metric.MEAN_RELATIVE_ERROR_DISTANCE, EXACT_OUTPUT, RESYNTH_OUTPUT
            )

            if error > config.error:
                return tree_circuit
            else:
                os.replace(RESYNTH_OUTPUT, APPROX_OUTPUT)
                tree_circuit = resynth_circuit

    return tree_circuit


def _run_constant_inputs(config: ApproxSynthesisConfig) -> Circuit:
    return config.circuit  # TODO Implement method


def _run_constant_outputs(config: ApproxSynthesisConfig) -> Circuit:
    return config.circuit  # TODO Implement method


def _run_probrun(config: ApproxSynthesisConfig) -> Circuit:
    return config.circuit  # TODO Implement method


def _run_significance(config: ApproxSynthesisConfig) -> Circuit:
    return config.circuit  # TODO Implement method


def _run_ccarving(config: ApproxSynthesisConfig) -> Circuit:
    return config.circuit  # TODO Implement method


def _compute_error_metrics(config: ApproxSynthesisConfig) -> Results:
    result: Results = {}
    for metric in config.metrics:
        if metric in _APPROXIMATION_ERROR_METRICS:
            error = compute_error(metric.value, EXACT_OUTPUT, APPROX_OUTPUT)
            result[metric] = error

    return result
