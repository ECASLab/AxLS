
from datetime import datetime
import random
import string
from typing import List
import numpy as np
import math
from random import randrange, gauss, triangular

def get_name(length):
    timestamp = datetime.now().strftime("%H%M%S")
    unique = ""
    for _ in range(length):
        unique += random.choice(string.ascii_letters)
    return f"{timestamp}{unique}"

def get_random(bits: int, distribution='uniform', samples=1, **kwargs):
    '''

    Generates samples of integer randomly distributed data.

    Parameters
    ----------
    bits: int
        Number of bits for the integer data.
    distribution: string
        Name of the desired random distribution. Could be:
            "gaussian" or "normal" for a normal distribution.
            "uniform" or "rectangular" for a uniform distribution.
            "triangular" for a triangular distribution.
            "shuffle_bag": Uniform, non-repeating values using a shuffle bag
                           algorithm. Should not be used for a lot of input bits,
                           see `Circuit.generate_dataset` docs for a detailed
                           explanation why.
            TODO: Add more distributions
    samples: int
        Number of samples.

    **kwargs (optional)
        median: int
            The center of the distribution (works only for certain distributions)
        std: int
            Standard deviation of the destribution (only gaussian/normal distribution)
        limits: int tuple
            Lower and upper limit of the dataset. By default it takes the whole range of numbers: [0,2^n-1]

    Returns
    -------
    data
        Randomized data sampled from the specified random distribution

    '''
    '''Pasing kwargs'''
    if 'low_limit' not in kwargs:
        low_limit=0 #Lower threshold for generated numbers
    else:
        low_limit=np.min([kwargs['low_limit'],2**bits])
    if 'high_limit' not in kwargs:
        high_limit=2**bits #Upper threshold for the generated data
    else:
        high_limit=np.min([kwargs['high_limit'],2**bits])
    if 'median' not in kwargs:
        median=(high_limit+low_limit)/2 #by default is centered at the mean
    else:
        median=kwargs['median']
    if 'variance' not in kwargs:
        variance=1
    else:
        variance=kwargs['variance']

    '''Distributions case'''
    data=[]
    if distribution in {'uniform', 'rectangular'}:
        data=(randrange(low_limit, high_limit) for _ in range(samples))

    # TODO: There's an issue with the `triangular` and `gauss` method, which is
    # that due to returning floats, they generate values were only around 50
    # MSBs have a non-zero value, which makes them unsuitable for larger
    # circuits that can have 64, 128, or even more input bits.

    elif distribution=='triangular':
        data=(int(math.floor(triangular(low_limit,high_limit,mode=median))) for _ in range(samples))
    elif distribution in {'normal', 'gaussian'}:
        while len(data)<samples:
            random_value=int(math.floor(gauss(median,variance)))
            if low_limit<=random_value<=high_limit:
                data.append(random_value)
    elif distribution == 'shuffle_bag':
        range_size = high_limit - low_limit
        num_cycles = math.ceil(samples / range_size)

        for i in range(num_cycles):
            bag = list(range(low_limit, high_limit))
            random.shuffle(bag)

            samples_remaining = samples - len(data)
            if samples_remaining > range_size:
                data.extend(bag)
            else:
                data.extend(bag[0:samples_remaining])
    else:
        raise ValueError(f'{distribution} is not a valid distribution name')

    return data

def read_dataset(filename: str, base: int, max_lines: None | int =None) -> List[List[int]]:
    """
    Reads a dataset or circuit output file like those generated by the
    `Circuit.generate_dataset` file or `Circuit.exact_output`.

    TODO: This function should be used by circuiterror.py.

    Parameters
    ----------
    filename : string
        The path to the file to be read.
    base : int
        The base of the numbers used by the file, common values are 16
        (hexadecimal) and 10 (decimal).
    max_lines : None | int
        The maximum amount of lines to read, in case the user doesn't want to
        use the entire dataset.

    Returns
    ----------
    dataset : List[List[int]]
        The data read from the file. The returned list is ordered by rows first,
        then columns. For example indexing dataset[2][5] requests the 5th
        element of the 2nd row.
    """
    with open(filename, "r") as f:
        if max_lines is not None:
            values = [
                [int(x, base) for x in line.split()]
                for _, line in zip(range(max_lines), f)
            ]
        else:
            values = [[int(x, base) for x in line.split()] for line in f]

        # Filter out empty lines
        return [value for value in values if value]
